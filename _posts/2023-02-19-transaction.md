## 并发导致的问题

### 第一类丢失更新

某个事物的回滚，导致另一个事务已更新的数据丢失。

| 时刻 | 事务1            | 事务2         |
| ---- | ---------------- | ------------- |
| T1   | read: N = 10     |               |
| T2   |                  | read: N = 10  |
| T3   |                  | write: N = 9  |
| T4   |                  | commit: N = 9 |
| T5   | write: N = 11    |               |
| T6   | rollback: N = 10 |               |

### 第二类丢失更新

某一个事物的提交，导致另一个事务已更新的数据丢失。

| 时刻 | 事务1          | 事务2         |
| ---- | -------------- | ------------- |
| T1   | read: N = 10   |               |
| T2   |                | read: N = 10  |
| T3   |                | write: N = 9  |
| T4   |                | commit: N = 9 |
| T5   | write: N = 11  |               |
| T6   | commit: N = 11 |               |

### 脏读

某一个事务，读取另外一个事务未提交的数据。

| 时刻 | 事务1           | 事务2       |
| ---- | --------------- | ----------- |
| T1   | read: N = 10    |             |
| T2   | write: N = 11   |             |
| T3   |                 | read: N =11 |
| T4   | rollback: N =10 |             |

### 不可重复读

某一个事务，对同一个数据前后读取不一致。

| 时刻 | 事务1         | 事务2        |
| ---- | ------------- | ------------ |
| T1   | read: N =10   |              |
| T2   |               | read: N = 10 |
| T3   | write: N = 11 |              |
| T4   | commit: N =11 |              |
| T5   |               | read: N = 11 |

### 幻读

某一个事务，对同一个表前后查询到的行数不一致。

| 时刻 | 事务1                     | 事务2                        |
| ---- | ------------------------- | ---------------------------- |
| T1   |                           | select: id < 10 (1, 2, 3)    |
| T2   | insert: id = 4            |                              |
| T3   | commit: id = (1, 2, 3, 4) |                              |
| T4   |                           | select: id < 10 (1, 2, 3, 4) |

## 事务隔离级别

##### 1、Read Uncommitted（读取未提交内容）

在该隔离级别中，所有事务可以看到其他未提交事务的执行结果。本级别隔离很少用于实际应用，比其他隔离级别性能也好不了多少。***读取未提交的数据成为“脏读”\***（Dirty Read）。

##### 2、Read Committed（读取提交内容）

这是大多数数据库默认的隔离级别，但是，不是MySQL的默认隔离级别。它满足了隔离简单的定义：一个事务只能看到已提交事务所做的改变。这种隔离会出现“不可重复读”的现象（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit（包括update和delete），导致目标数据被修改，所以同一select可能返回不同结果。

##### 3、Repeatable Read（可重读）

这是MySQL默认的隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行（目标数据行不会被修改）。不过，会出现“幻读”的现象。幻读是由insert引起的，简单来说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

##### 4、Serializable（可串行化）

这是最高的事务隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，它是在每个读的数据行上，加了共享锁，在这个级别，可能导致大量的超时现象和锁竞争。

| 隔离级别         | 第一类丢失更新 | 脏读 | 第二类丢失更新 | 不可重复读 | 幻读 |
| ---------------- | -------------- | ---- | -------------- | ---------- | ---- |
| read uncommitted | Y              | Y    | Y              | Y          | Y    |
| read committed   | N              | N    | Y              | Y          | Y    |
| repeatable read  | N              | N    | N              | N          | Y    |
| serializable     | N              | N    | N              | N          | N    |

## 事务传播方式

Require：**支持当前事务，**如果没有事务，就建一个新的，这是最常见的；

Requires_New：**新建事务**如果当前存在事务，把当前事务挂起；

Supports：**支持当前事务，**如果当前没有事务，就以非事务方式执行；

Not_Supported：**以非事务方式执行操作，**如果当前存在事务，就把事务挂起；

Mandatory：**支持当前事务，**如果当前没有事务，就抛出异常；

Never：**以非事务方式执行，**如果当前存在事务，则抛出异常。

Nested：**新建事务，**如果当前存在事务，把当前事务挂起。与Require_New的区别是与父事务相关，且有一个savepoint。即则在嵌套事务内执行。

## 实现机制

### 悲观锁（数据库）

悲观锁看待问题十分悲观，他认为一旦并发一定会出现问题。

- 共享锁（S锁）

  事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。

- 排他锁（X锁）

  事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。

### 乐观锁（自定义）

乐观锁看待并发很乐观，认为即使并发了也不会出现问题。

- 版本号、时间戳等

  在更新数据前，检查版本号是否发生变化。若发生变法则取消本次更新，否则就更新数据（版本号+1）