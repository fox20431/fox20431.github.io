对称加密，通信双方都是用同一把🔑来加密解密。

非对称加密，相互通信方都持有一对私钥和公钥，私钥自己持有，公钥公布他人。

假如A对B发送信息，A需要用B的公钥加密，B接受到加密信息在使用B自己的私钥解密。这样就能保证A想发给B的信息不会被别人窃听。
但是有个问题，由于B的公钥是公开的，此时C拿到B的公钥，也用B的公钥加密信息发给B，那么B怎么知道信息来自谁呢？
这时候需要用到数字签名，在每个信息之后，我们加上自己的签名，首先这个签名只针对这个消息，不然知道你的签名的人就可以拿着你的签名顶替你的身份散播别的信息。
这样怎么做到呢，数字签名的方法和信息加密解密相反，私钥加密公钥解密，为了防止由于信息的长度过长导致加密后签名过长（签名主要验证信息是否修改和个人信息，不需要对信息内容保真），信息使用散列值（hash）进行转换，再对结果进行加密。
A若想对B发送了一段5000字信息，那么A需要拿B的公钥对这段话加密，由于数字签名只是为了表明身份，在对文章信息使用hash算法压缩长度，再用私钥加密，然后一同发出去。
B这时候拿到信息，先用自己的私钥对信息解密，再用hash算法得出hash值。然后从一堆堆公钥中分别对着签名解密，找出解密结果与hash值相同的公钥，如果知道这个是谁的公钥，这时候就可以判断这个人的身份。
但在还有一种可能性，C使用B的电脑将A的公钥换成自己的公钥，B并不知道A的公钥被替换的情况下，C就可以顶替A的身份与B沟通。假如B和A是在讨论是否发射核弹，此时C顶替A说了一句话，发射，后果不堪设想。
上述问题如何解决？
我们找个有权威的第三方证明我身份不就行了，每次发送消息的时候让第三方帮我作证。这个第三方就是证书中心（certificate authority，简称CA），他对申请人进行身份验证，通过后发放其数字证书，数字证书上包含了申请人身份信息以及申请人的公钥等信息，以及CA私钥对前面信息的加密的数字签名。CA把自己的公钥公之于众，那么拿到CA公钥的人就又可以通过验证数字证书的数字签名，来验证证书信息的真实性，通过证书信息来得知对方是谁。
不对劲，怎么跟套娃一样？万一CA的公钥被改了呢？这不就死循环了吗？
这就涉及到根证书了，根证书存储了可信的CA（CA不止一家）公钥到系统上，是不可修改的。这样死循环就结束了。

数字证书不仅适用于非对称加密，也适用于对称加密。比如http协议中。

￼![eaf005d0a320c260](assets/eaf005d0a320c260.jpg)

这里返回的时候返回证书与公钥，由于这两个是公开的，谁都能盗用，所以并不能证明你的身份，这只能证明这个公钥的身份，至于这个公钥是不是你的，你需要表明你有公钥对应的私钥。这时候我用你给我的公钥加密我想的一串数字，你要是真有私钥，你就能用私钥解密出我的数字，我就承认你有私钥这个公钥就是你的。
确定完毕后，我核实你身份后，我就可以用对称加密来传输数据。这里使用对称加密是为了沟通便捷，非对称复杂不适合http。