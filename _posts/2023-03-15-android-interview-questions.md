# Android 常见问题汇总

问题源自平时面试汇总，答案来自ChatGPT、个人理解以及官方等。

## 基础

这方面主要包含：数据结构、算法、设计模式、计算机网络。

---

HTTP get和post的差别

HTTP 中的 GET 和 POST 是 HTTP 请求方法，它们的主要差异在于：

1. 数据传输方式：GET 方法通过 URL 向服务器传输数据，POST 方法通过请求体向服务器传输数据。

2. 数据长度限制：GET 方法发送的数据长度有限制，一般为 2KB 左右，而 POST 方法发送的数据长度没有限制。

3. 安全性：GET 方法的数据会被浏览器缓存，而 POST 方法的数据不会被缓存，因此 POST 方法更安全。

4. 参数传递方式：GET 方法将参数追加在 URL 后面，形如：http://www.example.com?key1=value1&key2=value2，而 POST 方法将参数放在请求体中，不会在 URL 中显示参数。

5. 应用场景：GET 方法适用于获取数据，如查询数据、搜索等，而 POST 方法适用于提交数据，如表单提交、文件上传等。

需要根据实际需求选择合适的请求方法，以实现最佳的效果和性能。需要注意的是，由于 GET 方法将参数追加在 URL 后面，因此在传输敏感数据时需要进行加密处理。同时，由于 POST 方法发送的数据长度没有限制，因此在发送大量数据时需要注意网络带宽的限制。


---

单例模式的懒汉和饿汉模式？

单例模式是一种常见的设计模式，它确保一个类只有一个实例，并提供一个全局访问点。在单例模式中，懒汉和饿汉是两种常见的实现方式。

懒汉模式：懒汉模式是指在第一次使用单例对象时才创建该对象。具体实现方式为在类中定义一个私有的静态成员变量，然后在第一次使用该对象时，检查该对象是否已经被创建。如果没有被创建，则创建该对象并返回，否则直接返回已经创建的对象。

优点：延迟加载，节省了系统资源。 缺点：线程不安全，需要加锁。

饿汉模式：饿汉模式是指在类加载的时候就已经创建了单例对象。具体实现方式为在类中定义一个私有的静态成员变量，并在静态代码块中创建该对象。

优点：线程安全，不需要加锁。 缺点：不支持延迟加载，可能浪费系统资源。

总结：

如果系统资源比较紧张，建议使用懒汉模式，否则建议使用饿汉模式。同时，如果要保证线程安全，需要在懒汉模式中加锁。

---

## 语言方面

主要是设计 Kotlin 和 Java 语言，线程安全一定要多背多看。

---

如何理解面向过程和面向对象？

面向过程和面向对象是两种不同的编程思想和方法。

面向过程（Procedural Programming）是一种基于任务的程序设计方法，它将程序看做一系列执行特定任务的函数或过程的集合。程序的执行过程是从头到尾线性执行的，每个函数或过程都是按照特定的顺序执行的。面向过程的程序设计方法着重于程序的功能和流程，它通常采用函数和结构体来组织程序代码。面向过程的程序设计方法适用于简单的程序和小规模的项目，但在处理复杂的系统和大规模的项目时会面临一些困难，如代码重用性差、维护难度大等。

面向对象（Object-Oriented Programming）是一种基于对象的程序设计方法，它将程序看做一组相互作用的对象的集合。每个对象都是一个独立的实体，具有自己的属性和行为。程序的执行过程是由对象之间的相互作用和消息传递来决定的。面向对象的程序设计方法着重于程序的结构和关系，它通常采用类、对象、继承和多态等概念来组织程序代码。面向对象的程序设计方法适用于复杂的系统和大规模的项目，它具有代码重用性高、维护难度小等优点。

总的来说，面向过程和面向对象是两种不同的编程思想和方法，它们各有优缺点，适用于不同的应用场景。在实际的编程过程中，应该根据具体的需求和项目特点选择合适的编程思想和方法。

---

JVM 的模型

JVM（Java虚拟机）内存模型包括以下几个主要的部分：

1. 堆（Heap）：堆是JVM内存模型中最大的一块内存区域，用于存储对象实例和数组。堆内存的大小可以通过命令行参数-Xmx和-Xms进行设置；
2. 栈（Stack）：每个线程都有一个独立的栈空间，用于存储线程的局部变量、方法参数和方法调用栈信息。栈内存的大小可以通过命令行参数-Xss进行设置；
3. 方法区（Method Area）：方法区用于存储类信息、常量池、静态变量、即时编译器编译后的代码等。方法区的大小可以通过命令行参数-XX:MaxPermSize进行设置；
4. 程序计数器（Program Counter Register）：程序计数器是每个线程私有的，用于记录当前线程执行的字节码指令地址；
5. 本地方法栈（Native Method Stack）：本地方法栈用于存储本地方法（Native Method）的信息，与Java虚拟机的实现相关。

JVM内存模型的不同部分具有不同的生命周期和访问权限。其中，堆内存是最重要的一部分，因为它存储了程序运行时创建的所有对象实例和数组。如果堆内存不足，就会发生OutOfMemoryError异常。栈内存的大小取决于线程数和方法调用深度，如果栈内存不足，就会发生StackOverflowError异常。方法区和本地方法栈的大小也会影响程序的性能和稳定性。

---

多态的三大特征

1. 继承（Inheritance）：多态是基于继承的，子类可以继承父类的属性和方法。子类可以重新定义或重载父类的方法，也可以新增自己的方法。
2. 重写（Override）：子类可以重写父类的方法，即在子类中定义一个与父类中同名、同参数列表、同返回类型的方法，但实现方式不同。重写方法必须具有相同的方法签名，即方法名、参数列表和返回类型必须完全一致。
3. 向上转型（Upcasting）：向上转型是指将子类对象赋值给父类引用变量的过程。这样做可以使得父类引用变量可以引用子类对象，从而实现多态。在向上转型过程中，父类引用变量只能访问父类中定义的属性和方法，而不能访问子类中新增或重写的属性和方法。

---

线程安全的数据类型

线程安全的数据类型是指在多线程环境下，可以保证数据操作的正确性和一致性的数据类型。常见的线程安全的数据类型包括：

1. ConcurrentHashMap：ConcurrentHashMap是线程安全的哈希表，它可以在多线程环境下高效地进行插入、删除和查找操作。
2. CopyOnWriteArrayList：CopyOnWriteArrayList是线程安全的动态数组，它采用写时复制的策略，在修改操作时会创建一个新的数组，从而避免了数据竞争和并发修改的问题。
3. ConcurrentLinkedQueue：ConcurrentLinkedQueue是线程安全的队列，它采用无锁的方式实现并发操作，可以高效地进行插入、删除和查找操作。
4. AtomicLong：AtomicLong是线程安全的长整型数据类型，它提供了原子性的操作方法，可以保证多线程环境下对长整型数据的操作的正确性和一致性。
5. Semaphore：Semaphore是一种线程同步的工具，它可以控制同时访问某个资源的线程数量，从而避免了资源竞争和死锁的问题。
6. CountDownLatch：CountDownLatch是一种线程同步的工具，它可以让一个或多个线程等待其他线程完成某个操作后再继续执行。

需要注意的是，虽然这些数据类型是线程安全的，但在具体的使用过程中仍需注意线程安全问题，避免数据竞争、死锁等问题的发生。

---

多线程的同步

比如ABCD四个异步请求事件，如何保证同步；

可以使用 CountDownLatch ，进行阻塞。

---

说说StringBuilder 和 StringBuffer 类区别

StringBuilder和StringBuffer都用于构建字符串

StringBuffer 是 Java 中用于字符串操作的类，它是线程安全的，因为它的方法都是使用 Syncniazed 关键字进行同步的，即同一时间只有一个线程可以访问 StringBuffer 对象。

## Android 相关

主要包含Android知识和Android相关的业务应用

---

Android 线程通讯方式

Handler，Handler 机制的核心是 Handler 类和 Message 类。Handler 类用于发送和处理消息，而 Message 类则用于封装消息。当 Handler 发送消息时，它将 Message 对象放入消息队列中，然后等待主线程的消息循环处理它。主线程的消息循环会不断地从消息队列中取出消息，并根据消息的类型和内容进行相应的处理。

---

四大组件

Android四大组件是指Activity、Service、BroadcastReceiver和ContentProvider，它们是Android应用程序的基本构成单元，用于实现不同的应用场景和功能。

1. Activity（活动）：是Android应用程序的用户界面组件，用于展示应用程序的UI界面和处理用户的交互操作。每个Activity都有自己的生命周期和状态，可以通过Intent来启动和销毁Activity。

2. Service（服务）：是Android应用程序的后台组件，用于执行长时间运行的任务和提供后台服务。Service可以在后台运行，即使应用程序退出或者用户切换到其他应用程序也不会停止运行。

3. BroadcastReceiver（广播接收器）：是Android应用程序的消息组件，用于接收系统或应用程序发出的广播消息，并根据消息类型执行相应的操作。广播可以是系统事件、应用程序事件或自定义事件，可以跨应用程序传递。

4. ContentProvider（内容提供器）：是Android应用程序的数据组件，用于管理应用程序的数据并提供数据共享。ContentProvider可以将应用程序的数据暴露给其他应用程序访问，也可以访问其他应用程序的数据。

这四大组件可以组合使用，实现复杂的应用程序功能。例如，Activity可以启动和停止Service，Service可以发送广播消息，BroadcastReceiver可以启动Activity或Service，ContentProvider可以提供数据给Activity或Service等。

---

Android 数据存储方式

SharedPreferences：SharedPreferences 是一种轻量级的数据存储方式，它可以将数据存储到 XML 文件中，适用于存储一些简单的键值对数据，如用户偏好设置、应用程序配置信息等。

文件存储：Android 应用程序可以将数据存储到文件中，适用于存储一些复杂的数据结构，如 JSON、XML、图片等。常用的文件存储方式包括内部存储和外部存储，内部存储是应用程序私有的存储空间，外部存储是共享的存储空间。

SQLite 数据库：SQLite 是 Android 中的一种轻量级关系型数据库，它可以存储结构化数据。SQLite 数据库适用于存储需要以表格形式组织的数据，如联系人信息、音乐信息等。

---

Android的事件分发

Android中的事件分发是指系统将用户的触摸事件分配给正确的视图进行处理的过程。事件分发涉及三个主要的组件：事件分发器（Dispatcher）、事件队列（Queue）和事件监听器（Listener）。

事件分发器（Dispatcher）是负责将事件分配给正确的视图的组件。事件队列（Queue）是存储所有待处理事件的地方。事件监听器（Listener）是视图定义的响应事件的代码块。

当用户触摸屏幕时，事件将被传递给顶级视图（如Activity或Fragment）。然后，事件将被分配给视图层次结构中的最外层视图。如果该视图不能处理该事件，则事件将被传递给视图层次结构中的下一个视图，直到找到能够处理事件的视图为止。

在事件分发过程中，Android会检查事件是否被消费。如果事件被消费，则不会再传递给其他视图。如果事件未被消费，则会传递给下一个视图进行处理。

总的来说，Android的事件分发机制是一个非常复杂的过程，它涉及到多个组件和多个阶段。了解这些组件和阶段，可以帮助开发者更好地理解Android的事件分发机制，从而更好地处理用户的触摸事件。

---

## 其他

我让 ChatGPT 出的问题也很有意思


问题：

请简单介绍一下Android系统架构？

请谈谈你对Android Activity生命周期的理解？

请解释一下Android中的Intent是什么？

请谈谈你对Android中的Fragment的理解？

请简述一下Android中的ViewGroup与View之间的关系？

请讲一下你对Android中的Handler机制的理解？

请谈谈你对Android中的广播机制的理解？

请简单介绍一下Android中的数据存储方式？

请谈谈你对Android中的线程和进程的理解？

请讲一下你对Android中的布局方式的理解？

答案：

Android系统架构包括四个层次：应用层、应用框架层、系统运行库层和Linux内核层。

Android Activity生命周期包括onCreate、onStart、onResume、onPause、onStop、onDestroy等方法，每个方法都有其对应的场景和作用。

Intent是Android中的一种消息传递机制，可以用来在应用组件之间传递数据和启动组件等操作。

Fragment是Android中的一种UI组件，可以用来实现灵活的UI布局和复杂的交互逻辑，同时也可以在不同的设备上进行适配。

ViewGroup是Android中的一种容器类组件，可以包含多个View组件，用来实现复杂的UI布局。

Handler机制是Android中的一种异步消息处理机制，可以用来在不同的线程之间传递消息和执行异步任务。

广播机制是Android中的一种消息传递机制，可以用来在应用组件之间传递消息和启动组件等操作，同时也可以用来接收系统和其他应用发送的消息。

Android中的数据存储方式包括SharedPreferences、SQLite数据库、文件存储和网络存储等方式。

Android中的线程和进程是操作系统中的基本概念，线程是程序执行的最小单位，进程是系统分配资源的最小单位，Android中可以通过多线程和多进程来实现复杂的应用逻辑。

Android中的布局方式包括线性布局、相对布局、帧布局、表格布局和约束布局等方式，每种布局方式都有其适用的场景和特点。



